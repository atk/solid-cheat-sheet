{"version":3,"mappings":"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","names":["sharedConfig","setHydrateContext","context","nextHydrateContext","equalFn","a","b","$PROXY","signalOptions","ERROR","runEffects","runQueue","STALE","PENDING","UNOWNED","NO_INIT","Owner","Transition","Listener","Updates","Effects","ExecCount","transPending","setTransPending","createSignal","createRoot","fn","detachedOwner","listener","owner","unowned","root","updateFn","untrack","cleanNode","runUpdates","value","options","s","setter","writeSignal","readSignal","createComputed","c","createComputation","updateComputation","createRenderEffect","createEffect","runUserEffects","SuspenseContext","lookup","createMemo","createResource","pSource","pFetcher","pOptions","source","fetcher","pr","initP","id","loadedUnderTransition","scheduled","resolved","dynamic","contexts","setValue","error","setError","track","trigger","state","setState","v","loadEnd","p","key","completeLoad","err","read","load","refetching","e","castError","result","on","deps","isArray","prevInput","defer","prevValue","input","i","onMount","onCleanup","onError","getOwner","runWithOwner","o","prev","startTransition","l","t","res","resumeEffects","createContext","defaultValue","createProvider","useContext","ctx","children","memo","resolveChildren","getSuspenseContext","runningTransition","updates","lookUpstream","sSlot","node","isComp","current","TransitionRunning","markDownstream","time","runComputation","nextValue","handleError","init","pure","runTop","ancestors","top","wait","completeUpdates","sources","disposed","d","len","queue","userLength","ignore","index","obs","n","reset","fns","f","results","props","hydrationEnabled","enableHydration","createComponent","Comp","trueFn","propTraps","_","property","receiver","resolveSource","mergeProps","keys","target","descriptors","splitProps","blocked","isProxy","k","clone","lazy","comp","wrap","set","mod","r","counter","createUniqueId","Show","strictEqual","keyed","condition","child","Errors","resetErrorBoundaries","ErrorBoundary","errored","setErrored","SuspenseListContext","Suspense","show","flicker","inFallback","setFallback","store","ref","listContext","dispose","rendered","showContent","showFallback","disposer","booleans","Properties","ChildProperties","Aliases","PropAliases","DelegatedEvents","SVGElements","SVGNamespace","reconcileArrays","parentNode","bLength","aEnd","bEnd","aStart","bStart","after","map","sequence","$$EVENTS","render","code","element","insert","template","html","check","isSVG","delegateEvents","eventNames","document","name","eventHandler","setAttribute","setAttributeNS","namespace","className","addEventListener","handler","delegate","handlerFn","classList","classKeys","prevKeys","toggleClassKey","classValue","style","nodeStyle","spread","skipChildren","prevProps","insertExpression","assign","parent","accessor","marker","initial","skipRef","prop","assignProp","hydrate$1","gatherHydratable","getNextElement","getHydrationKey","getNextMarker","start","end","count","runHydrationEvents","events","el","completed","toPropertyName","w","classNames","nameLen","isCE","isProp","isChildProp","ns","elem","data","unwrapArray","multi","cleanChildren","array","currentArray","normalizeIncomingArray","appendNodes","normalized","unwrap","item","replacement","inserted","isParent","templates","hydrate","NoHydration","voidFn","isServer","SVG_NAMESPACE","createElement","tagName","args","Dynamic","others","cached","component","isSvg","mount","MetaContext","cascadingTags","getTagType","tag","MetaProvider","ssrTags","head","querySelectorAll","Array","prototype","forEach","call","ssrTag","removeChild","cascadedTagInstances","Map","getElement","querySelector","toLowerCase","removeAttribute","actions","addClientTag","tagType","indexOf","has","instances","get","length","lastVisited","appendChild","removeClientTag","_$createComponent","MetaTag","Error","useHead","tagDesc","addServerTag","Title","Meta","bindEvent","type","intercept","selector","scrollToHash","hash","fallbackTop","createIntegration","utils","signal","next","normalizeIntegration","integration","pathIntegration","replace","scroll","notify","delta","hasSchemeRegex","trimPathRegex","normalize","path","omitSlash","resolvePath","base","from","basePath","fromPath","invariant","message","joinPaths","to","extractSearchParams","url","params","urlDecode","str","isQuery","createMatcher","partial","pattern","splat","segments","location","locSegments","lenDiff","match","segment","locSegment","scoreRoute","route","score","createMemoObject","expandOptionals","prefix","suffix","prefixes","expansion","MAX_REDIRECTS","RouterContextObj","RouteContextObj","useRouter","TempRoute","useRoute","useResolvedPath","useHref","router","to_","useLocation","createRoutes","routeDef","fallback","isLeaf","shared","asArray","acc","originalPath","createBranch","routes","matches","createBranches","stack","branches","routeDefs","def","branch","getRouteMatches","createLocation","origin","path_","pathname","search","createRouterContext","out","setSource","parsePath","renderPath","output","isRouting","setIsRouting","callback","reference","setReference","referrers","baseRoute","navigatorFactory","navigateFromRoute","nextState","resolvedTo","resolve","navigateEnd","first","handleAnchorClick","evt","href","rel","createRouteContext","outlet","preload","Router","routerState","Routes","parentRoute","Outlet","push","disposers","routeStates","nextMatches","prevMatches","equal","prevMatch","nextMatch","splice","A","inactiveClass","activeClass","rest","isActive","undefined","split","loc","startsWith","JSON","stringify","ErrorBoundaryBase","ErrorMessage","console","_$delegateEvents","ServerContext","FETCH_EVENT","isDev","import","hydrationEvents","isIslands","Scripts","isSSR","HydrationScript","Html","documentElement","Head","Body","body","childNodes","els","filter","Boolean","Root","FileRoutes","rootData","Object","values","dataFn","default","StartClient","mockFetchEvent","request","prevUrl","responseHeaders","tags","env","routerContext","setStatusCode","getStatusCode","$type","fetch","StartRouter"],"sources":["../../../node_modules/solid-js/dist/solid.js","../../../node_modules/solid-js/web/dist/web.js","../../../node_modules/solid-start/entry-client/mount.tsx","../../../node_modules/@solidjs/meta/dist/index.jsx","../../../node_modules/@solidjs/router/dist/integration.js","../../../node_modules/@solidjs/router/dist/utils.js","../../../node_modules/@solidjs/router/dist/routing.js","../../../node_modules/@solidjs/router/dist/components.jsx","../../../node_modules/solid-start/error-boundary/ErrorBoundary.tsx","../../../node_modules/solid-start/server/ServerContext.tsx","../../../node_modules/solid-start/server/types.tsx","../../../node_modules/solid-start/root/Scripts.tsx","../../../node_modules/solid-start/root/Document.tsx","../../../src/root.tsx","../../../node_modules/solid-start/entry-client/StartClient.tsx","../../../src/entry-client.tsx"],"sourcesContent":["let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if (arguments.length === 2 && typeof pFetcher === \"object\" || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null,\n      initP = NO_INIT,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n        [value, setValue] = (options.storage || createSignal)(options.initialValue),\n        [error, setError] = createSignal(undefined),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    let v;\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;else if (sharedConfig.load && (v = sharedConfig.load(id))) initP = v[0];\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (!err) setValue(() => v);\n      setState(err ? \"errored\" : \"ready\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value(),\n          err = error();\n    if (err && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(p && \"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, undefined, castError(e)));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const [key, val] of subs.entries()) if (fn(key, v) !== fn(key, p)) {\n      for (const c of val.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    if (!runningTransition && this.state === STALE || runningTransition && this.tState === STALE) updateComputation(this);else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n            if (o.pure) Updates.push(o);else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (false) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) Transition && Transition.running ? node.tState = STALE : node.state = STALE;\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!Updates) Effects = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error || typeof err === \"string\") return err;\n  return new Error(\"Unknown error\");\n}\nfunction handleError(err) {\n  err = castError(err);\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  for (const f of fns) f(err);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }), undefined);\n    return res;\n  };\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === 'function' ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  if (sources.some(s => s && ($PROXY in s || typeof s === \"function\"))) {\n    return new Proxy({\n      get(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          const v = resolveSource(sources[i])[property];\n          if (v !== undefined) return v;\n        }\n      },\n      has(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          if (property in resolveSource(sources[i])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const target = {};\n  for (let i = sources.length - 1; i >= 0; i--) {\n    if (sources[i]) {\n      const descriptors = Object.getOwnPropertyDescriptors(sources[i]);\n      for (const key in descriptors) {\n        if (key in target) continue;\n        Object.defineProperty(target, key, {\n          enumerable: true,\n          get() {\n            for (let i = sources.length - 1; i >= 0; i--) {\n              const v = (sources[i] || {})[key];\n              if (v !== undefined) return v;\n            }\n          }\n        });\n      }\n    }\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const isProxy = ($PROXY in props);\n  if (!isProxy) keys.push(Object.keys(descriptors).filter(k => !blocked.has(k)));\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      if (!isProxy && !(key in props)) continue;\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        },\n        enumerable: true\n      });\n    }\n    return clone;\n  });\n  if (isProxy) {\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? undefined : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter(k => !blocked.has(k));\n      }\n    }, propTraps));\n  }\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      strictEqual = keyed || fn;\n      return fn ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  let keyed = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) {\n        keyed = !!conds[i].keyed;\n        return [i, c, conds[i]];\n      }\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    const fn = typeof c === \"function\" && c.length > 0;\n    strictEqual = keyed || fn;\n    return fn ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  let v;\n  if (sharedConfig.context && sharedConfig.load && (v = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count))) err = v[0];\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if (e = errored()) {\n      const f = props.fallback;\n      const res = typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n      onError(setErrored);\n      return res;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n    inFallback: false\n  })),\n      show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(prev => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          {\n      showContent = true,\n      showFallback = true\n    } = show ? show() : {},\n          reg = registry(),\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(inFallback => !inFallback());\n      const res = reg.map(() => ({\n        showContent: all && showContent,\n        showFallback\n      }));\n      res.inFallback = !all;\n      return res;\n    }\n    let stop = false;\n    let inFallback = prev.inFallback;\n    const res = [];\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = reg[n]();\n      if (!stop && !s) {\n        res[n] = {\n          showContent,\n          showFallback\n        };\n      } else {\n        const next = !stop;\n        if (next) inFallback = true;\n        res[n] = {\n          showContent: next,\n          showFallback: !tail || next && tail === \"collapsed\" ? showFallback : false\n        };\n        stop = true;\n      }\n    }\n    if (!stop) inFallback = false;\n    res.inFallback = inFallback;\n    return res;\n  }, {\n    inFallback: false\n  });\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n      show,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    let ref = sharedConfig.load(key);\n    if (ref && (p = ref[0]) && p !== \"$$f\") {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if (err || sharedConfig.done) {\n          err && (error = err);\n          return set();\n        }\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n                {\n            showContent = true,\n            showFallback = true\n          } = show ? show() : {};\n          if ((!inFallback || p && p !== \"$$f\") && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { createRoot, createRenderEffect, sharedConfig, untrack, enableHydration, createSignal, onCleanup, splitProps, createMemo } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, createMemo as memo, mergeProps, untrack } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /*#__PURE__*/new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /*#__PURE__*/new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = /*#__PURE__*/Object.assign(Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /*#__PURE__*/Object.assign(Object.create(null), {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n});\nconst DelegatedEvents = /*#__PURE__*/new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /*#__PURE__*/new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/new Set([\"html\", \"base\", \"head\", \"link\", \"meta\", \"style\", \"title\", \"body\", \"address\", \"article\", \"aside\", \"footer\", \"header\", \"main\", \"nav\", \"section\", \"body\", \"blockquote\", \"dd\", \"div\", \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\", \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"area\", \"audio\", \"img\", \"map\", \"track\", \"video\", \"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"portal\", \"source\", \"svg\", \"math\", \"canvas\", \"noscript\", \"script\", \"del\", \"ins\", \"caption\", \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"button\", \"datalist\", \"fieldset\", \"form\", \"input\", \"label\", \"legend\", \"meter\", \"optgroup\", \"option\", \"output\", \"progress\", \"select\", \"textarea\", \"details\", \"dialog\", \"menu\", \"summary\", \"details\", \"slot\", \"template\", \"acronym\", \"applet\", \"basefont\", \"bgsound\", \"big\", \"blink\", \"center\", \"content\", \"dir\", \"font\", \"frame\", \"frameset\", \"hgroup\", \"image\", \"keygen\", \"marquee\", \"menuitem\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"rb\", \"rtc\", \"shadow\", \"spacer\", \"strike\", \"tt\", \"xmp\", \"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"portal\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\", \"input\"]);\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = e => handlerFn.call(node, handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => props.ref && props.ref(node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes], options);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev);\n    value && node.addEventListener(e, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (prop === \"class\" || prop === \"className\") className(node, value);else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach(elem => elem.remove());\n  }\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      if (!array.length) return current;\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        prev = current && current[i];\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if ((typeof item) === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) {\n        normalized.push(prev);\n      } else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\nfunction Hydration(props) {\n  return props.children;\n}\nfunction voidFn() {}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction ssrElement(name, props, children, needsId) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrAttribute(key, value) {}\nfunction ssrHydrationKey() {}\nfunction resolveSSRNode(node) {}\nfunction escape(html) {}\nfunction ssrSpread(props, isSVG, skipChildren) {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      },\n      configurable: true\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p.component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, voidFn as Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Hydration, voidFn as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, className, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, voidFn as generateHydrationScript, voidFn as getAssets, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrAttribute, ssrClassList, ssrElement, ssrHydrationKey, ssrSpread, ssrStyle, style, template, use, voidFn as useAssets };\n","import type { JSX } from \"solid-js\";\nimport { getOwner } from \"solid-js\";\nimport { createComponent, getNextElement, hydrate, render } from \"solid-js/web\";\n\nimport mountRouter from \"../islands/router\";\n\ndeclare global {\n  interface Window {\n    INSPECT: () => void;\n  }\n}\n\nif (import.meta.env.DEV) {\n  localStorage.setItem(\"debug\", import.meta.env.DEBUG ?? \"start*\");\n  // const { default: createDebugger } = await import(\"debug\");\n  // window.DEBUG = createDebugger(\"start:client\");\n  window.DEBUG = console.log as unknown as any;\n\n  DEBUG(`import.meta.env.DEV = ${import.meta.env.DEV}`);\n  DEBUG(`import.meta.env.PROD = ${import.meta.env.PROD}`);\n  DEBUG(`import.meta.env.START_SSR = ${import.meta.env.START_SSR}`);\n  DEBUG(`import.meta.env.START_ISLANDS = ${import.meta.env.START_ISLANDS}`);\n  DEBUG(`import.meta.env.START_ISLANDS_ROUTER = ${import.meta.env.START_ISLANDS_ROUTER}`);\n  DEBUG(`import.meta.env.SSR = ${import.meta.env.SSR}`);\n\n  window.INSPECT = () => {\n    window.open(window.location.href.replace(window.location.pathname, \"/__inspect\"));\n  };\n}\n\nfunction lookupOwner(el: HTMLElement) {\n  const parent = el.closest(\"solid-children\");\n  return parent && (parent as any).__$owner;\n}\n\nexport default function mount(code?: () => JSX.Element, element?: Document) {\n  if (import.meta.env.START_ISLANDS) {\n    mountRouter();\n\n    async function mountIsland(el: HTMLElement) {\n      let Component = window._$HY.islandMap[el.dataset.island];\n      if (!Component || !el.dataset.hk) return;\n      DEBUG(\n        \"hydrating island\",\n        el.dataset.island,\n        el.dataset.hk.slice(0, el.dataset.hk.length - 1) + `1-`,\n        el\n      );\n\n      hydrate(\n        () =>\n          createComponent(Component, {\n            ...JSON.parse(el.dataset.props),\n            get children() {\n              const el = getNextElement();\n              (el as any).__$owner = getOwner();\n              return;\n            }\n          }),\n        el,\n        {\n          renderId: el.dataset.hk.slice(0, el.dataset.hk.length - 1) + `1-`,\n          owner: lookupOwner(el)\n        }\n      );\n\n      delete el.dataset.hk;\n    }\n\n    let queue = [];\n    let queued = false;\n    function runTaskQueue(info) {\n      while (info.timeRemaining() > 0 && queue.length) {\n        mountIsland(queue.shift());\n      }\n      if (queue.length) {\n        requestIdleCallback(runTaskQueue);\n      } else queued = false;\n    }\n    window._$HY.hydrateIslands = () => {\n      const islands = document.querySelectorAll(\"solid-island[data-hk]\");\n      const assets = new Set<string>();\n      islands.forEach(el => assets.add(el.dataset.component));\n      Promise.all([...assets].map(asset => import(/* @vite-ignore */ asset))).then(() => {\n        islands.forEach((el: HTMLElement) => {\n          if (el.dataset.when === \"idle\" && \"requestIdleCallback\" in window) {\n            if (!queued) {\n              queued = true;\n              requestIdleCallback(runTaskQueue);\n            }\n            queue.push(el);\n          } else mountIsland(el as HTMLElement);\n        });\n      });\n    };\n    window._$HY.fe = window._$HY.hydrateIslands;\n\n    window._$HY.hydrateIslands();\n\n    return;\n  } else if (import.meta.env.START_ISLANDS_ROUTER) {\n    mountRouter();\n    return;\n  }\n\n  if (import.meta.env.START_SSR) {\n    hydrate(code, element);\n  } else {\n    render(code, element === document ? element.body : element);\n  }\n}\n","import { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst getTagType = (tag) => tag.tag + (tag.name ? `.${tag.name}\"` : \"\");\nconst MetaProvider = props => {\n    if (!isServer && !sharedConfig.context) {\n        const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n        // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n        Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\n    }\n    const cascadedTagInstances = new Map();\n    // TODO: use one element for all tags of the same type, just swap out\n    // where the props get applied\n    function getElement(tag) {\n        if (tag.ref) {\n            return tag.ref;\n        }\n        let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n        if (el) {\n            if (el.tagName.toLowerCase() !== tag.tag) {\n                if (el.parentNode) {\n                    // remove the old tag\n                    el.parentNode.removeChild(el);\n                }\n                // add the new tag\n                el = document.createElement(tag.tag);\n            }\n            // use the old tag\n            el.removeAttribute(\"data-sm\");\n        }\n        else {\n            // create a new tag\n            el = document.createElement(tag.tag);\n        }\n        return el;\n    }\n    const actions = {\n        addClientTag: (tag) => {\n            let tagType = getTagType(tag);\n            if (cascadingTags.indexOf(tag.tag) !== -1) {\n                //  only cascading tags need to be kept as singletons\n                if (!cascadedTagInstances.has(tagType)) {\n                    cascadedTagInstances.set(tagType, []);\n                }\n                let instances = cascadedTagInstances.get(tagType);\n                let index = instances.length;\n                instances = [...instances, tag];\n                // track indices synchronously\n                cascadedTagInstances.set(tagType, instances);\n                if (!isServer) {\n                    let element = getElement(tag);\n                    tag.ref = element;\n                    spread(element, tag.props);\n                    let lastVisited = null;\n                    for (var i = index - 1; i >= 0; i--) {\n                        if (instances[i] != null) {\n                            lastVisited = instances[i];\n                            break;\n                        }\n                    }\n                    if (element.parentNode != document.head) {\n                        document.head.appendChild(element);\n                    }\n                    if (lastVisited && lastVisited.ref) {\n                        document.head.removeChild(lastVisited.ref);\n                    }\n                }\n                return index;\n            }\n            if (!isServer) {\n                let element = getElement(tag);\n                tag.ref = element;\n                spread(element, tag.props);\n                if (element.parentNode != document.head) {\n                    document.head.appendChild(element);\n                }\n            }\n            return -1;\n        },\n        removeClientTag: (tag, index) => {\n            const tagName = getTagType(tag);\n            if (tag.ref) {\n                const t = cascadedTagInstances.get(tagName);\n                if (t) {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                        for (let i = index - 1; i >= 0; i--) {\n                            if (t[i] != null) {\n                                document.head.appendChild(t[i].ref);\n                            }\n                        }\n                    }\n                    t[index] = null;\n                    cascadedTagInstances.set(tagName, t);\n                }\n                else {\n                    if (tag.ref.parentNode) {\n                        tag.ref.parentNode.removeChild(tag.ref);\n                    }\n                }\n            }\n        }\n    };\n    if (isServer) {\n        actions.addServerTag = (tagDesc) => {\n            const { tags = [] } = props;\n            // tweak only cascading tags\n            if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n                const index = tags.findIndex(prev => {\n                    const prevName = prev.props.name || prev.props.property;\n                    const nextName = tagDesc.props.name || tagDesc.props.property;\n                    return prev.tag === tagDesc.tag && prevName === nextName;\n                });\n                if (index !== -1) {\n                    tags.splice(index, 1);\n                }\n            }\n            tags.push(tagDesc);\n        };\n        if (Array.isArray(props.tags) === false) {\n            throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n        }\n    }\n    return <MetaContext.Provider value={actions}>{props.children}</MetaContext.Provider>;\n};\nconst MetaTag = (tag, props) => {\n    const id = createUniqueId();\n    const c = useContext(MetaContext);\n    if (!c)\n        throw new Error(\"<MetaProvider /> should be in the tree\");\n    useHead({\n        tag,\n        props,\n        id,\n        get name() {\n            return props.name || props.property;\n        }\n    });\n    return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n    const { addClientTag, removeClientTag, addServerTag } = useContext(MetaContext);\n    createRenderEffect(() => {\n        if (!isServer) {\n            let index = addClientTag(tagDesc);\n            onCleanup(() => removeClientTag(tagDesc, index));\n        }\n    });\n    if (isServer) {\n        addServerTag(tagDesc);\n        return null;\n    }\n}\nexport function renderTags(tags) {\n    return tags\n        .map(tag => {\n        const keys = Object.keys(tag.props);\n        const props = keys.map(k => (k === \"children\" ? \"\" : ` ${k}=\"${tag.props[k]}\"`)).join(\"\");\n        return tag.props.children\n            ? `<${tag.tag} data-sm=\"${tag.id}\"${props}>${\n            // Tags might contain multiple text children:\n            //   <Title>example - {myCompany}</Title>\n            Array.isArray(tag.props.children) ? tag.props.children.join(\"\") : tag.props.children}</${tag.tag}>`\n            : `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n    })\n        .join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props);\nexport const Style = props => MetaTag(\"style\", props);\nexport const Meta = props => MetaTag(\"meta\", props);\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => <Link rel=\"stylesheet\" {...props}/>;\n","import { createSignal, onCleanup } from \"solid-js\";\nfunction bindEvent(target, type, handler) {\n    target.addEventListener(type, handler);\n    return () => target.removeEventListener(type, handler);\n}\nfunction intercept([value, setValue], get, set) {\n    return [get ? () => get(value()) : value, set ? (v) => setValue(set(v)) : setValue];\n}\nfunction querySelector(selector) {\n    // Guard against selector being an invalid CSS selector\n    try {\n        return document.querySelector(selector);\n    }\n    catch (e) {\n        return null;\n    }\n}\nfunction scrollToHash(hash, fallbackTop) {\n    const el = querySelector(`#${hash}`);\n    if (el) {\n        el.scrollIntoView();\n    }\n    else if (fallbackTop) {\n        window.scrollTo(0, 0);\n    }\n}\nexport function createIntegration(get, set, init, utils) {\n    let ignore = false;\n    const wrap = (value) => (typeof value === \"string\" ? { value } : value);\n    const signal = intercept(createSignal(wrap(get()), { equals: (a, b) => a.value === b.value }), undefined, next => {\n        !ignore && set(next);\n        return next;\n    });\n    init &&\n        onCleanup(init((value = get()) => {\n            ignore = true;\n            signal[1](wrap(value));\n            ignore = false;\n        }));\n    return {\n        signal,\n        utils\n    };\n}\nexport function normalizeIntegration(integration) {\n    if (!integration) {\n        return {\n            signal: createSignal({ value: \"\" })\n        };\n    }\n    else if (Array.isArray(integration)) {\n        return {\n            signal: integration\n        };\n    }\n    return integration;\n}\nexport function staticIntegration(obj) {\n    return {\n        signal: [() => obj, next => Object.assign(obj, next)]\n    };\n}\nexport function pathIntegration() {\n    return createIntegration(() => ({\n        value: window.location.pathname + window.location.search + window.location.hash,\n        state: history.state\n    }), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", value);\n        }\n        else {\n            window.history.pushState(state, \"\", value);\n        }\n        scrollToHash(window.location.hash.slice(1), scroll);\n    }, notify => bindEvent(window, \"popstate\", () => notify()), {\n        go: delta => window.history.go(delta)\n    });\n}\nexport function hashIntegration() {\n    return createIntegration(() => window.location.hash.slice(1), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", \"#\" + value);\n        }\n        else {\n            window.location.hash = value;\n        }\n        const hashIndex = value.indexOf(\"#\");\n        const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\n        scrollToHash(hash, scroll);\n    }, notify => bindEvent(window, \"hashchange\", () => notify()), {\n        go: delta => window.history.go(delta),\n        renderPath: path => `#${path}`,\n        parsePath: str => {\n            const to = str.replace(/^.*?#/, \"\");\n            // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\n            // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\n            // to the current path so we can handle these in-page anchors correctly.\n            if (!to.startsWith(\"/\")) {\n                const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\n                return `${path}#${to}`;\n            }\n            return to;\n        }\n    });\n}\n","import { createMemo, getOwner, runWithOwner } from \"solid-js\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|\\/+$/g;\nfunction normalize(path, omitSlash = false) {\n    const s = path.replace(trimPathRegex, \"\");\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\n}\nexport function resolvePath(base, path, from) {\n    if (hasSchemeRegex.test(path)) {\n        return undefined;\n    }\n    const basePath = normalize(base);\n    const fromPath = from && normalize(from);\n    let result = \"\";\n    if (!fromPath || path.startsWith(\"/\")) {\n        result = basePath;\n    }\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n        result = basePath + fromPath;\n    }\n    else {\n        result = fromPath;\n    }\n    return (result || \"/\") + normalize(path, !result);\n}\nexport function invariant(value, message) {\n    if (value == null) {\n        throw new Error(message);\n    }\n    return value;\n}\nexport function joinPaths(from, to) {\n    return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\nexport function extractSearchParams(url) {\n    const params = {};\n    url.searchParams.forEach((value, key) => {\n        params[key] = value;\n    });\n    return params;\n}\nexport function urlDecode(str, isQuery) {\n    return decodeURIComponent(isQuery ? str.replace(/\\+/g, \" \") : str);\n}\nexport function createMatcher(path, partial) {\n    const [pattern, splat] = path.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    const len = segments.length;\n    return (location) => {\n        const locSegments = location.split(\"/\").filter(Boolean);\n        const lenDiff = locSegments.length - len;\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n            return null;\n        }\n        const match = {\n            path: len ? \"\" : \"/\",\n            params: {}\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments[i];\n            const locSegment = locSegments[i];\n            if (segment[0] === \":\") {\n                match.params[segment.slice(1)] = locSegment;\n            }\n            else if (segment.localeCompare(locSegment, undefined, { sensitivity: \"base\" }) !== 0) {\n                return null;\n            }\n            match.path += `/${locSegment}`;\n        }\n        if (splat) {\n            match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n        }\n        return match;\n    };\n}\nexport function scoreRoute(route) {\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMemoObject(fn) {\n    const map = new Map();\n    const owner = getOwner();\n    return new Proxy({}, {\n        get(_, property) {\n            if (!map.has(property)) {\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n            }\n            return map.get(property)();\n        },\n        getOwnPropertyDescriptor() {\n            return {\n                enumerable: true,\n                configurable: true\n            };\n        },\n        ownKeys() {\n            return Reflect.ownKeys(fn());\n        }\n    });\n}\nexport function mergeSearchString(search, params) {\n    const merged = new URLSearchParams(search);\n    Object.entries(params).forEach(([key, value]) => {\n        if (value == null || value === \"\") {\n            merged.delete(key);\n        }\n        else {\n            merged.set(key, String(value));\n        }\n    });\n    const s = merged.toString();\n    return s ? `?${s}` : \"\";\n}\nexport function expandOptionals(pattern) {\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n    if (!match)\n        return [pattern];\n    let prefix = pattern.slice(0, match.index);\n    let suffix = pattern.slice(match.index + match[0].length);\n    const prefixes = [prefix, (prefix += match[1])];\n    // This section handles adjacent optional params. We don't actually want all permuations since\n    // that will lead to equivalent routes which have the same number of params. For example\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n    // ensure predictability where earlier params have precidence.\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n        prefixes.push((prefix += match[1]));\n        suffix = suffix.slice(match[0].length);\n    }\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n","import { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"solid-js\";\nimport { isServer, delegateEvents } from \"solid-js/web\";\nimport { normalizeIntegration } from \"./integration\";\nimport { createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, urlDecode, expandOptionals } from \"./utils\";\nconst MAX_REDIRECTS = 100;\nexport const RouterContextObj = createContext();\nexport const RouteContextObj = createContext();\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\nlet TempRoute;\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\nexport const useResolvedPath = (path) => {\n    const route = useRoute();\n    return createMemo(() => route.resolvePath(path()));\n};\nexport const useHref = (to) => {\n    const router = useRouter();\n    return createMemo(() => {\n        const to_ = to();\n        return to_ !== undefined ? router.renderPath(to_) : to_;\n    });\n};\nexport const useNavigate = () => useRouter().navigatorFactory();\nexport const useLocation = () => useRouter().location;\nexport const useIsRouting = () => useRouter().isRouting;\nexport const useMatch = (path) => {\n    const location = useLocation();\n    const matcher = createMemo(() => createMatcher(path()));\n    return createMemo(() => matcher()(location.pathname));\n};\nexport const useParams = () => useRoute().params;\nexport const useRouteData = () => useRoute().data;\nexport const useSearchParams = () => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const setSearchParams = (params, options) => {\n        const searchString = untrack(() => mergeSearchString(location.search, params));\n        navigate(location.pathname + searchString, { scroll: false, ...options });\n    };\n    return [location.query, setSearchParams];\n};\nexport function createRoutes(routeDef, base = \"\", fallback) {\n    const { component, data, children } = routeDef;\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\n    const shared = {\n        key: routeDef,\n        element: component\n            ? () => createComponent(component, {})\n            : () => {\n                const { element } = routeDef;\n                return element === undefined && fallback\n                    ? createComponent(fallback, {})\n                    : element;\n            },\n        preload: routeDef.component\n            ? component.preload\n            : routeDef.preload,\n        data\n    };\n    return asArray(routeDef.path).reduce((acc, path) => {\n        for (const originalPath of expandOptionals(path)) {\n            const path = joinPaths(base, originalPath);\n            const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n            acc.push({\n                ...shared,\n                originalPath,\n                pattern,\n                matcher: createMatcher(pattern, !isLeaf)\n            });\n        }\n        return acc;\n    }, []);\n}\nexport function createBranch(routes, index = 0) {\n    return {\n        routes,\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n        matcher(location) {\n            const matches = [];\n            for (let i = routes.length - 1; i >= 0; i--) {\n                const route = routes[i];\n                const match = route.matcher(location);\n                if (!match) {\n                    return null;\n                }\n                matches.unshift({\n                    ...match,\n                    route\n                });\n            }\n            return matches;\n        }\n    };\n}\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\nexport function createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\n    const routeDefs = asArray(routeDef);\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\n        const def = routeDefs[i];\n        if (def && typeof def === \"object\" && def.hasOwnProperty(\"path\")) {\n            const routes = createRoutes(def, base, fallback);\n            for (const route of routes) {\n                stack.push(route);\n                if (def.children) {\n                    createBranches(def.children, route.pattern, fallback, stack, branches);\n                }\n                else {\n                    const branch = createBranch([...stack], branches.length);\n                    branches.push(branch);\n                }\n                stack.pop();\n            }\n        }\n    }\n    // Stack will be empty on final return\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nexport function getRouteMatches(branches, location) {\n    for (let i = 0, len = branches.length; i < len; i++) {\n        const match = branches[i].matcher(location);\n        if (match) {\n            return match;\n        }\n    }\n    return [];\n}\nexport function createLocation(path, state) {\n    const origin = new URL(\"http://sar\");\n    const url = createMemo(prev => {\n        const path_ = path();\n        try {\n            return new URL(path_, origin);\n        }\n        catch (err) {\n            console.error(`Invalid path ${path_}`);\n            return prev;\n        }\n    }, origin, {\n        equals: (a, b) => a.href === b.href\n    });\n    const pathname = createMemo(() => urlDecode(url().pathname));\n    const search = createMemo(() => urlDecode(url().search, true));\n    const hash = createMemo(() => urlDecode(url().hash));\n    const key = createMemo(() => \"\");\n    return {\n        get pathname() {\n            return pathname();\n        },\n        get search() {\n            return search();\n        },\n        get hash() {\n            return hash();\n        },\n        get state() {\n            return state();\n        },\n        get key() {\n            return key();\n        },\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\n    };\n}\nexport function createRouterContext(integration, base = \"\", data, out) {\n    const { signal: [source, setSource], utils = {} } = normalizeIntegration(integration);\n    const parsePath = utils.parsePath || (p => p);\n    const renderPath = utils.renderPath || (p => p);\n    const basePath = resolvePath(\"\", base);\n    const output = isServer && out\n        ? Object.assign(out, {\n            matches: [],\n            url: undefined\n        })\n        : undefined;\n    if (basePath === undefined) {\n        throw new Error(`${basePath} is not a valid base path`);\n    }\n    else if (basePath && !source().value) {\n        setSource({ value: basePath, replace: true, scroll: false });\n    }\n    const [isRouting, setIsRouting] = createSignal(false);\n    const start = async (callback) => {\n        setIsRouting(true);\n        try {\n            await startTransition(callback);\n        }\n        finally {\n            setIsRouting(false);\n        }\n    };\n    const [reference, setReference] = createSignal(source().value);\n    const [state, setState] = createSignal(source().state);\n    const location = createLocation(reference, state);\n    const referrers = [];\n    const baseRoute = {\n        pattern: basePath,\n        params: {},\n        path: () => basePath,\n        outlet: () => null,\n        resolvePath(to) {\n            return resolvePath(basePath, to);\n        }\n    };\n    if (data) {\n        try {\n            TempRoute = baseRoute;\n            baseRoute.data = data({\n                data: undefined,\n                params: {},\n                location,\n                navigate: navigatorFactory(baseRoute)\n            });\n        }\n        finally {\n            TempRoute = undefined;\n        }\n    }\n    function navigateFromRoute(route, to, options) {\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n        untrack(() => {\n            if (typeof to === \"number\") {\n                if (!to) {\n                    // A delta of 0 means stay at the current location, so it is ignored\n                }\n                else if (utils.go) {\n                    utils.go(to);\n                }\n                else {\n                    console.warn(\"Router integration does not support relative routing\");\n                }\n                return;\n            }\n            const { replace, resolve, scroll, state: nextState } = {\n                replace: false,\n                resolve: true,\n                scroll: true,\n                ...options\n            };\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\n            if (resolvedTo === undefined) {\n                throw new Error(`Path '${to}' is not a routable path`);\n            }\n            else if (referrers.length >= MAX_REDIRECTS) {\n                throw new Error(\"Too many redirects\");\n            }\n            const current = reference();\n            if (resolvedTo !== current || nextState !== state()) {\n                if (isServer) {\n                    if (output) {\n                        output.url = resolvedTo;\n                    }\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\n                }\n                else {\n                    const len = referrers.push({ value: current, replace, scroll, state: state() });\n                    start(() => {\n                        setReference(resolvedTo);\n                        setState(nextState);\n                        resetErrorBoundaries();\n                    }).then(() => {\n                        if (referrers.length === len) {\n                            navigateEnd({\n                                value: resolvedTo,\n                                state: nextState\n                            });\n                        }\n                    });\n                }\n            }\n        });\n    }\n    function navigatorFactory(route) {\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n        route = route || useContext(RouteContextObj) || baseRoute;\n        return (to, options) => navigateFromRoute(route, to, options);\n    }\n    function navigateEnd(next) {\n        const first = referrers[0];\n        if (first) {\n            if (next.value !== first.value || next.state !== first.state) {\n                setSource({\n                    ...next,\n                    replace: first.replace,\n                    scroll: first.scroll\n                });\n            }\n            referrers.length = 0;\n        }\n    }\n    createRenderEffect(() => {\n        const { value, state } = source();\n        // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\n        untrack(() => {\n            if (value !== reference()) {\n                start(() => {\n                    setReference(value);\n                    setState(state);\n                });\n            }\n        });\n    });\n    if (!isServer) {\n        function handleAnchorClick(evt) {\n            if (evt.defaultPrevented ||\n                evt.button !== 0 ||\n                evt.metaKey ||\n                evt.altKey ||\n                evt.ctrlKey ||\n                evt.shiftKey)\n                return;\n            const a = evt\n                .composedPath()\n                .find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\n            if (!a || !a.hasAttribute(\"link\"))\n                return;\n            const href = a.href;\n            if (a.target || (!href && !a.hasAttribute(\"state\")))\n                return;\n            const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\n            if (a.hasAttribute(\"download\") || (rel && rel.includes(\"external\")))\n                return;\n            const url = new URL(href);\n            const pathname = urlDecode(url.pathname);\n            if (url.origin !== window.location.origin ||\n                (basePath && pathname && !pathname.toLowerCase().startsWith(basePath.toLowerCase())))\n                return;\n            const to = parsePath(pathname + urlDecode(url.search, true) + urlDecode(url.hash));\n            const state = a.getAttribute(\"state\");\n            evt.preventDefault();\n            navigateFromRoute(baseRoute, to, {\n                resolve: false,\n                replace: a.hasAttribute(\"replace\"),\n                scroll: !a.hasAttribute(\"noscroll\"),\n                state: state && JSON.parse(state)\n            });\n        }\n        // ensure delegated events run first\n        delegateEvents([\"click\"]);\n        document.addEventListener(\"click\", handleAnchorClick);\n        onCleanup(() => document.removeEventListener(\"click\", handleAnchorClick));\n    }\n    return {\n        base: baseRoute,\n        out: output,\n        location,\n        isRouting,\n        renderPath,\n        parsePath,\n        navigatorFactory\n    };\n}\nexport function createRouteContext(router, parent, child, match) {\n    const { base, location, navigatorFactory } = router;\n    const { pattern, element: outlet, preload, data } = match().route;\n    const path = createMemo(() => match().path);\n    const params = createMemoObject(() => match().params);\n    preload && preload();\n    const route = {\n        parent,\n        pattern,\n        get child() {\n            return child();\n        },\n        path,\n        params,\n        data: parent.data,\n        outlet,\n        resolvePath(to) {\n            return resolvePath(base.path(), to, path());\n        }\n    };\n    if (data) {\n        try {\n            TempRoute = route;\n            route.data = data({ data: parent.data, params, location, navigate: navigatorFactory(route) });\n        }\n        finally {\n            TempRoute = undefined;\n        }\n    }\n    return route;\n}\n","/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths } from \"./utils\";\nexport const Router = (props) => {\n    const { source, url, base, data, out } = props;\n    const integration = source || (isServer ? staticIntegration({ value: url || \"\" }) : pathIntegration());\n    const routerState = createRouterContext(integration, base, data, out);\n    return (<RouterContextObj.Provider value={routerState}>{props.children}</RouterContextObj.Provider>);\n};\nexport const Routes = (props) => {\n    const router = useRouter();\n    const parentRoute = useRoute();\n    const routeDefs = children(() => props.children);\n    const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n    const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n    if (router.out) {\n        router.out.matches.push(matches().map(({ route, path, params }) => ({\n            originalPath: route.originalPath,\n            pattern: route.pattern,\n            path,\n            params\n        })));\n    }\n    const disposers = [];\n    let root;\n    const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n        let equal = prevMatches && nextMatches.length === prevMatches.length;\n        const next = [];\n        for (let i = 0, len = nextMatches.length; i < len; i++) {\n            const prevMatch = prevMatches && prevMatches[i];\n            const nextMatch = nextMatches[i];\n            if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n                next[i] = prev[i];\n            }\n            else {\n                equal = false;\n                if (disposers[i]) {\n                    disposers[i]();\n                }\n                createRoot(dispose => {\n                    disposers[i] = dispose;\n                    next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i]);\n                });\n            }\n        }\n        disposers.splice(nextMatches.length).forEach(dispose => dispose());\n        if (prev && equal) {\n            return prev;\n        }\n        root = next[0];\n        return next;\n    }));\n    return (<Show when={routeStates() && root}>\n      {((route) => (<RouteContextObj.Provider value={route}>{route.outlet()}</RouteContextObj.Provider>))}\n    </Show>);\n};\nexport const useRoutes = (routes, base) => {\n    return () => <Routes base={base}>{routes}</Routes>;\n};\nexport const Route = (props) => {\n    const childRoutes = children(() => props.children);\n    return mergeProps(props, {\n        get children() {\n            return childRoutes();\n        }\n    });\n};\nexport const Outlet = () => {\n    const route = useRoute();\n    return (<Show when={route.child}>\n      {((child) => (<RouteContextObj.Provider value={child}>{child.outlet()}</RouteContextObj.Provider>))}\n    </Show>);\n};\nexport function A(props) {\n    props = mergeProps({ inactiveClass: \"inactive\", activeClass: \"active\" }, props);\n    const [, rest] = splitProps(props, [\"href\", \"state\", \"activeClass\", \"inactiveClass\", \"end\"]);\n    const to = useResolvedPath(() => props.href);\n    const href = useHref(to);\n    const location = useLocation();\n    const isActive = createMemo(() => {\n        const to_ = to();\n        if (to_ === undefined)\n            return false;\n        const path = to_.split(/[?#]/, 1)[0].toLowerCase();\n        const loc = location.pathname.toLowerCase();\n        return props.end ? path === loc : loc.startsWith(path);\n    });\n    return (<a link {...rest} href={href() || props.href} state={JSON.stringify(props.state)} classList={{\n            [props.inactiveClass]: !isActive(),\n            [props.activeClass]: isActive(),\n            ...rest.classList\n        }} aria-current={isActive() ? \"page\" : undefined}/>);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { href, state } = props;\n    const path = typeof href === \"function\" ? href({ navigate, location }) : href;\n    navigate(path, { replace: true, state });\n    return null;\n}\n","import {\n  createEffect,\n  ErrorBoundary as ErrorBoundaryBase,\n  JSX,\n  ParentProps,\n  resetErrorBoundaries,\n  Show\n} from \"solid-js\";\n\nexport function ErrorBoundary(props: ParentProps<{ fallback?: (e: any, reset: () => void) => JSX.Element }>) {\n  return (\n    <ErrorBoundaryBase\n      fallback={(e, reset) => {\n        return (\n          <Show when={!props.fallback} fallback={props.fallback(e, reset)}>\n            <ErrorMessage error={e} />\n          </Show>\n        );\n      }}\n    >\n      {props.children}\n    </ErrorBoundaryBase>\n  );\n}\n\nexport function ErrorMessage(props: { error: any }) {\n  createEffect(() => console.error(props.error));\n\n  return (\n    <div style={{ padding: \"16px\" }}>\n      <div\n        style={{\n          \"background-color\": \"rgba(252, 165, 165)\",\n          color: \"rgb(153, 27, 27)\",\n          \"border-radius\": \"5px\",\n          overflow: \"scroll\",\n          padding: \"16px\",\n          \"margin-bottom\": \"8px\"\n        }}\n      >\n        <p style={{ \"font-weight\": \"bold\" }} id=\"error-message\">\n          {props.error.message}\n        </p>\n        <button\n          id=\"reset-errors\"\n          onClick={resetErrorBoundaries}\n          style={{\n            color: \"rgba(252, 165, 165)\",\n            \"background-color\": \"rgb(153, 27, 27)\",\n            \"border-radius\": \"5px\",\n            padding: \"4px 8px\"\n          }}\n        >\n          Clear errors and retry\n        </button>\n        <pre style={{ \"margin-top\": \"8px\", width: \"100%\" }}>{props.error.stack}</pre>\n      </div>\n    </div>\n  );\n}\n","import { PageEvent } from \"./types\";\n\nimport { createContext, useContext } from \"solid-js\";\n\nexport const ServerContext = createContext<PageEvent>({} as any);\n\nexport const useServerContext = () => {\n  return useContext(ServerContext)!;\n};\n","export type ManifestEntry = {\n  type: string;\n  href: string;\n};\n\nexport const FETCH_EVENT = \"$FETCH\";\n\nexport type ContextMatches = {\n  originalPath: string;\n  pattern: string;\n  path: string;\n  params: unknown;\n};\n\ntype TagDescription = {\n  tag: string;\n  props: Record<string, unknown>;\n};\n\ntype RouterContext = {\n  // router matches;\n  matches?: ContextMatches[][];\n  // redirected url\n  url?: string;\n\n  // server route fragments\n  replaceOutletId?: string;\n  newOutletId?: string;\n};\n\nexport type IslandManifest = {\n  script: ManifestEntry;\n  assets: ManifestEntry[];\n};\n\ndeclare global {\n  interface Env {\n    /**\n     * BE CAREFUL WHILE USING. AVAILABLE IN PRODUCTION ONLY.\n     */\n    manifest?: Record<string, ManifestEntry[] | IslandManifest>;\n    /**\n     * BE CAREFUL WHILE USING. AVAILABLE IN PRODUCTION ONLY.\n     */\n    getStaticHTML?(path: string): Promise<Response>;\n    /**\n     * BE CAREFUL WHILE USING. AVAILABLE IN PRODUCTION ONLY.\n     */\n    __dev?: {\n      /**\n       * @warning\n       */\n      collectStyles?: (matches: string[]) => Promise<Record<string, string>>;\n      manifest?: [{ path: string; componentPath: string; id: string }];\n    };\n  }\n}\n\nexport interface FetchEvent {\n  request: Request;\n  env: Env;\n}\n\nexport interface ServerFunctionEvent extends FetchEvent {\n  fetch(url: string, init: RequestInit): Promise<Response>;\n  $type: typeof FETCH_EVENT;\n}\n\nexport interface PageEvent extends FetchEvent {\n  prevUrl: string;\n  responseHeaders: Headers;\n  routerContext?: RouterContext;\n  tags?: TagDescription[];\n  setStatusCode(code: number): void;\n  getStatusCode(): number;\n  fetch(url: string, init: RequestInit): Promise<Response>;\n  $type: typeof FETCH_EVENT;\n}\n","import { useContext } from \"solid-js\";\nimport { HydrationScript, isServer, NoHydration } from \"solid-js/web\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { InlineStyles } from \"./InlineStyles\";\n\nconst isDev = import.meta.env.MODE === \"development\";\nconst isSSR = import.meta.env.START_SSR;\nconst hydrationEvents = typeof import.meta.env.HYDRATION_EVENTS === 'string'\n  ? import.meta.env.HYDRATION_EVENTS.split(/\\W\\s*/g)\n  : undefined;\nconst isIslands = import.meta.env.START_ISLANDS;\n\nexport default function Scripts() {\n  const context = useContext(ServerContext);\n  return (\n    <>\n      {isSSR && <HydrationScript eventNames={hydrationEvents} />}\n      {isIslands && (\n        <script>{`\n        _$HY.islandMap = {};\n        _$HY.island = (u, c) => _$HY.islandMap[u] = c;\n      `}</script>\n      )}\n      <NoHydration>\n        {isServer &&\n          (isDev ? (\n            <>\n              <script type=\"module\" src=\"/@vite/client\" $ServerOnly></script>\n              <script\n                type=\"module\"\n                async\n                src={\"/@fs/\" + import.meta.env.START_ENTRY_CLIENT}\n                $ServerOnly\n              ></script>\n            </>\n          ) : isSSR ? (\n            <script type=\"module\" async src={context.env.manifest[\"entry-client\"][0].href} />\n          ) : import.meta.env.START_INDEX_HTML ? (\n            // used in the SPA build index.html mode to create a reference to index html\n            // which will be used by the client build\n            <script type=\"module\" async src={import.meta.env.START_ENTRY_CLIENT} $ServerOnly />\n          ) : (\n            <script type=\"module\" async src={context.env.manifest[\"index.html\"][0].href} />\n          ))}\n      </NoHydration>\n      {isDev && <InlineStyles />}\n    </>\n  );\n}\n","import type { JSX } from \"solid-js\";\nimport { children, ComponentProps } from \"solid-js\";\nimport { insert, NoHydration, spread, ssrElement } from \"solid-js/web\";\nimport Links from \"./Links\";\nimport Meta from \"./Meta\";\nimport Scripts from \"./Scripts\";\n\nexport function Html(props: ComponentProps<\"html\">) {\n  if (import.meta.env.START_ISLANDS) {\n    return NoHydration({\n      get children() {\n        return ssrElement(\"html\", props, undefined, false) as unknown as JSX.Element;\n      }\n    });\n  }\n  if (import.meta.env.SSR) {\n    return ssrElement(\"html\", props, undefined, false) as unknown as JSX.Element;\n  }\n  spread(document.documentElement, props, false, true);\n  return props.children;\n}\n\nexport function Head(props: ComponentProps<\"head\">) {\n  if (import.meta.env.SSR) {\n    return ssrElement(\n      \"head\",\n      props,\n      () => (\n        <>\n          {props.children}\n          <Meta />\n          <Links />\n        </>\n      ),\n      false\n    ) as unknown as JSX.Element;\n  } else {\n    spread(document.head, props, false, true);\n    return props.children;\n  }\n}\n\nexport function Body(props: ComponentProps<\"body\">) {\n  if (import.meta.env.SSR) {\n    return ssrElement(\n      \"body\",\n      props,\n      () => (import.meta.env.START_SSR ? props.children : <Scripts />),\n      false\n    ) as unknown as JSX.Element;\n  } else {\n    if (import.meta.env.START_SSR) {\n      let child = children(() => props.children);\n      spread(document.body, props, false, true);\n      insert(\n        document.body,\n        () => {\n          let childNodes = child();\n          if (childNodes) {\n            if (Array.isArray(childNodes)) {\n              let els = childNodes.filter(n => Boolean(n));\n\n              if (!els.length) {\n                return null;\n              }\n\n              return els;\n            }\n            return childNodes;\n          }\n          return null;\n        },\n        null,\n        [...document.body.childNodes]\n      );\n\n      return document.body;\n    } else {\n      spread(document.body, props, false, true);\n      return props.children;\n    }\n  }\n}\n","// @refresh reload\nimport { Routes } from \"@solidjs/router\";\nimport { Suspense } from \"solid-js\";\nimport { ErrorBoundary } from \"solid-start/error-boundary\";\nimport {\n  Body,\n  FileRoutes,\n  Head,\n  Html,\n  Meta,\n  Scripts,\n  Title,\n} from \"solid-start\";\nimport \"./root.css\";\n\nexport default function Root() {\n  return (\n    <Html lang=\"en\">\n      <Head>\n        <Title>Solid Cheat Sheet</Title>\n        <Meta charset=\"utf-8\" />\n        <Meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n      </Head>\n      <Body>\n        <ErrorBoundary>\n          <Suspense>\n            <Routes>\n              <FileRoutes />\n            </Routes>\n          </Suspense>\n        </ErrorBoundary>\n        <Scripts />\n      </Body>\n    </Html>\n  );\n}\n","import { MetaProvider } from \"@solidjs/meta\";\nimport { Router, RouterProps } from \"@solidjs/router\";\nimport Root from \"~start/root\";\nimport { ServerContext } from \"../server/ServerContext\";\nimport { FETCH_EVENT, PageEvent } from \"../server/types\";\n\nconst rootData: { default: <T>() => Promise<T> } = Object.values(\n  import.meta.glob(\"/src/root.data.(js|ts)\", { eager: true })\n)[0] as any;\nconst dataFn = rootData ? rootData.default : undefined;\n\nfunction throwClientError(field: string): any {\n  throw new Error(\n    `\"${field}\" is not available on the client. Use it within an \\`if (isServer)\\` block to ensure it only runs on the server`\n  );\n}\n\nexport default () => {\n  let mockFetchEvent: PageEvent = {\n    get request() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"request\");\n      }\n    },\n    get prevUrl() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"request\");\n      }\n    },\n    get responseHeaders() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"responseHeaders\");\n      }\n    },\n    get tags() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"tags\");\n      }\n    },\n    get env() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"env\");\n      }\n    },\n    get routerContext() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"routerContext\");\n      }\n    },\n    setStatusCode(code: number) {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"setStatusCode\");\n      }\n    },\n    getStatusCode() {\n      if (process.env.NODE_ENV === \"development\") {\n        return throwClientError(\"getStatusCode\");\n      }\n    },\n    $type: FETCH_EVENT,\n    fetch\n  };\n\n  function StartRouter(props: RouterProps) {\n    return (\n      <Router {...props}>\n        <Root />\n      </Router>\n    );\n  }\n\n  return (\n    <ServerContext.Provider value={mockFetchEvent}>\n      <MetaProvider>\n        <StartRouter data={dataFn}>\n          <Root />\n        </StartRouter>\n      </MetaProvider>\n    </ServerContext.Provider>\n  );\n};\n","import { mount, StartClient } from \"solid-start/entry-client\";\n\nmount(() => <StartClient />, document);\n"],"file":"assets/entry-client.ca85c609.js"}